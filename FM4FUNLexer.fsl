// The generated lexer module will start with this code
{
module FM4FUNLexer
open FSharp.Text.Lexing
open System.Globalization
open System
// open the module that defines the tokens
open FM4FUNParser
}

// Macros for regular expressions:
let keywords = ("if"|"fi"|"do"|"od"|"skip"|"true"|"false")
let digit = ['0'-'9']
let var = ['a'-'z''A'-'Z'](['a'-'z']|['A'-'Z']|digit|'_')*
let num = digit+
let whitespace = ['\u00A0' ' ' '\n' '\r' '\t']
// OBS: We could not make \u00A0 work with "regular" whitespaces, so 
// we added ' ' to the regular expression. 

// Rules for each token in our language:
rule tokenize = parse

// Checking first for keywords with a mandatory whitespace
| "if" whitespace   { IF }
| whitespace "fi"   { FI }
| "do" whitespace   { DO }
| whitespace "od"   { OD }

// Then ignoring the rest of whitespace
| whitespace        { tokenize lexbuf }
| ":="              { ASSIGN }
| "skip"            { SKIP }
| ';'               { SEP }
| "->"              { THEN }
| "[]"              { CONS }
| '['               { LBRA }
| ']'               { RBRA }
| '+'               { PLUS }
| '-'               { MINUS }
| '*'               { MULT }
| '/'               { DIV }
| '^'               { POW }
| '('               { LPAR }
| ')'               { RPAR }
| "true"            { TRUE }
| "false"           { FALSE }
| "&&"              { SAND }
| "||"              { SOR }
| '&'               { AND }
| '|'               { OR }
| "!="              { NEQ }
| ">="              { GEQ }
| "<="              { LEQ }
| '='               { EQ }
| '>'               { GT }
| '<'               { LT }
| '!'               { NOT }

// Ignore the keyword so that no token is created, this way the parser will pick up
// the errors when no token is at a expected 
| "if"              { failwith (sprintf "\"if\" is not allowed here: Char %d" (lexbuf.EndPos.AbsoluteOffset)) }
| "fi"              { failwith (sprintf "\"fi\" is not allowed here: Char %d" (lexbuf.EndPos.AbsoluteOffset)) }
| "do"              { failwith (sprintf "\"do\" is not allowed here: Char %d" (lexbuf.EndPos.AbsoluteOffset)) }
| "od"              { failwith (sprintf "\"od\" is not allowed here: Char %d" (lexbuf.EndPos.AbsoluteOffset)) }

// Lastly it checks for variable names. Since the rules are applied top-down
| var               { VAR(LexBuffer<_>.LexemeString lexbuf)}
| num               { NUM((int) (LexBuffer<_>.LexemeString lexbuf)) }
| eof               { EOF }
| _                 { failwith (sprintf "Unknown failure at: Char %d" (lexbuf.EndPos.AbsoluteOffset)) }






