// Open the file that defines the type "expr" we shall use as AST
%{
open FM4FUNTypesAST
%}

// Declare the tokens (terminal symbols)
%token <integer> NUM
%token <string> VAR
%token ASSIGN 
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
//%left PLUS MINUS
//%left TIMES DIV
//%right POW


// We declare the initial non-terminal symbol
%start start

// We specify the return type of each of then non-terminal symbols
%type <expr> start
%type <expr> expression0
%type <expr> expression1
%type <expr> expression2
%type <expr> expression3

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: expression0 EOF             { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

expression0: // Associates to the left
  | expression0 PLUS expression1  { PlusExpr($1,$3) }
  | expression0 MINUS expression1 { MinusExpr($1,$3) }
  | expression1                   { $1 }

expression1: // Associates to the left
  | expression1 TIMES expression2 { TimesExpr($1,$3) }
  | expression1 DIV expression2   { DivExpr($1,$3) }
  | expression1 MOD expression2   { ModExpr($1,$3) }
  | expression2                   { $1 }

expression2: // Associates to the right
  | expression3 POW expression2   { PowExpr($1,$3) }
  | expression3                   { $1 }

expression3: // Associate doesn't matter
  | MINUS expression3             { UMinusExpr($2) }
  | PLUS expression3              { UPlusExpr($2) }
  | SQRT expression3              { SqrtExpr($2) }
  | LOG expression3               { LogExpr($2) }
  | LN expression3                { LnExpr($2) }
  | NUM                           { Num($1) }
  | LPAR expression0 RPAR         { $2 }

// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
