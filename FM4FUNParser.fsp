// Open the file that defines the type "expr" we shall use as AST
%{
open FM4FUNAST
%}

// Declare the tokens (terminal symbols)
%token <int> NUM
%token <string> VAR
%token ASSIGN SKIP SEP IF FI DO OD THEN CONS LBRA RBRA PLUS MINUS MULT DIV POW LPAR RPAR TRUE FALSE AND OR SAND SOR NEQ GEQ LEQ EQ GT LT NOT EOF
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
//%left PLUS MINUS
//%left TIMES DIV
//%right POW


// We declare the initial non-terminal symbol
%start start

// We specify the return type of each of then non-terminal symbols
%type <cexp> start
%type <cexp> C
%type <gcexp> GC
%type <aexp> a
%type <bexp> b

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: C EOF                      { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

C: // Associates to the *****
  | VAR ASSIGN a                  { Assign(Var($1),$3) }      // x := a
  | VAR LBRA a RBRA ASSIGN a      { Assign(Array($1,$3),$6) } // A[a] := a
  | SKIP                          { Skip }                    // skip
  | C SEP C                       { C($1,$3) }                // C ; C
  | IF GC FI                      { If($2) }                  // if GC fi
  | DO GC OD                      { Do($2) }                  // do GC od

GC: // Associates to the *****
  | b THEN C                      { Then($1,$3) }             // b -> C
  | GC CONS GC                    { GC($1,$3) }               // GC [] GC

a: // Associates to the ******
  | NUM                           { Num($1) }                 // n
  | VAR                           { V(Var($1)) }                 // x
  | VAR LBRA a RBRA               { V(Array($1,$3)) }            // A[a]
  | a PLUS a                      { Plus($1,$3) }             // a + a
  | a MINUS a                     { Minus($1,$3) }            // a - a
  | a MULT a                      { Mult($1,$3) }             // a * a
  | a DIV a                       { Div($1,$3) }              // a / a
  | MINUS a                       { UMinus($2) }              // -a
  | a POW a                       { Pow($1,$3) }              // a ^ a
  | LPAR a RPAR                   { $2 }                      // (a)

b: // Associate ******
  | TRUE                          { True }                    // true
  | FALSE                         { False }                   // false
  | b SAND b                      { SAnd($1,$3) }             // b & b
  | b SOR b                       { SOr($1,$3) }              // b | b
  | b AND b                       { And($1,$3) }              // b && b
  | b OR b                        { Or($1,$3) }               // b || b
  | NOT b                         { Not($2) }                 // !b
  | a EQ a                        { Eq($1,$3) }               // a = a
  | a NEQ a                       { Neq($1,$3) }              // a != a
  | a GT a                        { Gt($1,$3) }               // a > a
  | a GEQ a                       { Geq($1,$3) }              // a >= a
  | a LT a                        { Lt($1,$3) }               // a < a
  | a LEQ a                       { Leq($1,$3) }              // a <= a
  | LPAR b RPAR                   { $2 }                      // (b)

// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
